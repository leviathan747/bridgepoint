/*
 * generated by Xtext 2.9.2
 */
package org.xtuml.bp.xtext.masl.validation

import com.google.common.collect.HashMultimap
import com.google.inject.Inject
import java.util.HashSet
import java.util.Set
import java.util.regex.Pattern
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.resource.IResourceDescriptions
import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider
import org.eclipse.xtext.validation.Check
import org.xtuml.bp.xtext.masl.MASLExtensions
import org.xtuml.bp.xtext.masl.masl.AssocRelationshipDefinition
import org.xtuml.bp.xtext.masl.masl.CharacteristicCall
import org.xtuml.bp.xtext.masl.masl.CodeBlock
import org.xtuml.bp.xtext.masl.masl.DomainDefinition
import org.xtuml.bp.xtext.masl.masl.DomainFunctionDeclaration
import org.xtuml.bp.xtext.masl.masl.DomainFunctionDefinition
import org.xtuml.bp.xtext.masl.masl.DomainServiceDeclaration
import org.xtuml.bp.xtext.masl.masl.DomainServiceDefinition
import org.xtuml.bp.xtext.masl.masl.EnumerationTypeDefinition
import org.xtuml.bp.xtext.masl.masl.IdentifierDefinition
import org.xtuml.bp.xtext.masl.masl.IndexedExpression
import org.xtuml.bp.xtext.masl.masl.MaslModel
import org.xtuml.bp.xtext.masl.masl.MaslPackage
import org.xtuml.bp.xtext.masl.masl.ObjectDeclaration
import org.xtuml.bp.xtext.masl.masl.ObjectDefinition
import org.xtuml.bp.xtext.masl.masl.ObjectFunctionDeclaration
import org.xtuml.bp.xtext.masl.masl.ObjectFunctionDefinition
import org.xtuml.bp.xtext.masl.masl.ObjectServiceDeclaration
import org.xtuml.bp.xtext.masl.masl.ObjectServiceDefinition
import org.xtuml.bp.xtext.masl.masl.OperationCall
import org.xtuml.bp.xtext.masl.masl.Parameterized
import org.xtuml.bp.xtext.masl.masl.ProjectDefinition
import org.xtuml.bp.xtext.masl.masl.RegularRelationshipDefinition
import org.xtuml.bp.xtext.masl.masl.RelationshipDefinition
import org.xtuml.bp.xtext.masl.masl.RelationshipEnd
import org.xtuml.bp.xtext.masl.masl.RelationshipNavigation
import org.xtuml.bp.xtext.masl.masl.SimpleFeatureCall
import org.xtuml.bp.xtext.masl.masl.StateDeclaration
import org.xtuml.bp.xtext.masl.masl.StateDefinition
import org.xtuml.bp.xtext.masl.masl.StructureTypeDefinition
import org.xtuml.bp.xtext.masl.masl.SubtypeRelationshipDefinition
import org.xtuml.bp.xtext.masl.masl.TerminatorDefinition
import org.xtuml.bp.xtext.masl.masl.TerminatorFunctionDeclaration
import org.xtuml.bp.xtext.masl.masl.TerminatorFunctionDefinition
import org.xtuml.bp.xtext.masl.masl.TerminatorOperationCall
import org.xtuml.bp.xtext.masl.masl.TerminatorServiceDeclaration
import org.xtuml.bp.xtext.masl.masl.TerminatorServiceDefinition
import org.xtuml.bp.xtext.masl.masl.TransitionRow
import org.xtuml.bp.xtext.masl.maslBase.MaslBasePackage

import static org.xtuml.bp.xtext.masl.validation.IssueCodes.*

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MASLValidator extends AbstractMASLValidator {

	@Inject extension MaslPackage
	@Inject extension MaslBasePackage
	@Inject extension MASLExtensions
	@Inject extension IQualifiedNameProvider
	@Inject extension ResourceDescriptionsProvider

	@Check
	def void structureComponentDefs(StructureTypeDefinition it) {
		if (components.empty)
			error('A structure must specify at least one component', it, null, ILLEGAL_EMPTY_LIST)
	}

	@Check
	def void enumerators(EnumerationTypeDefinition it) {
		if (enumerators.empty)
			error('An enumeration must specify at least one enumerator', it, null, ILLEGAL_EMPTY_LIST)
	}

	@Check
	def void attributeReferentials(IdentifierDefinition it) {
		if (attributes.empty)
			error('An attribute referential must specify at least one referential', it, null, ILLEGAL_EMPTY_LIST)
	}

	@Check
	def void identifierAttributes(IdentifierDefinition it) {
		if (attributes.empty)
			error('An identifier must specify at least one attribute', it, null, ILLEGAL_EMPTY_LIST)
	}

	@Check
	def void transitionOptions(TransitionRow it) {
		if (options.empty)
			error('A transition row must specify at least one option', it, null, ILLEGAL_EMPTY_LIST)
	}

	@Check
	def void subtypes(SubtypeRelationshipDefinition it) {
		if (subtypes.empty)
			error('A subtype relationship must specify at least one subtype', it, null, ILLEGAL_EMPTY_LIST)
	}
	
	@Check 
	def void domainDefinitionInProject(ProjectDefinition project) {
		project.domains.forEach [
			 (objects + services + functions + relationships + objectDefs + typeForwards + types + exceptions)
			 .forEach[
			 	error('Only terminator definitions are allowed in a project', it, abstractNamed_Name)
			 ]
		]
	}

	@Check
	def void relationshipEndsAreOpposites(RegularRelationshipDefinition it) {
		if (forwards.from != backwards.to) {
			error('Relationship objects do not correlate', forwards, relationshipEnd_From, INCONSISTENT_RELATIONSHIP_ENDS)
			error('Relationship objects do not correlate', backwards, relationshipEnd_To, INCONSISTENT_RELATIONSHIP_ENDS)
		}
		if (forwards.to != backwards.from) {
			error('Relationship objects do not correlate', forwards, relationshipEnd_To, INCONSISTENT_RELATIONSHIP_ENDS)
			error('Relationship objects do not correlate', backwards, relationshipEnd_From, INCONSISTENT_RELATIONSHIP_ENDS)
		}
	}

	@Check
	def void relationshipEndsAreOpposites(AssocRelationshipDefinition it) {
		if (forwards.from != backwards.to) {
			error('Relationship objects do not correlate', forwards, relationshipEnd_From, INCONSISTENT_RELATIONSHIP_ENDS)
			error('Relationship objects do not correlate', backwards, relationshipEnd_To, INCONSISTENT_RELATIONSHIP_ENDS)
		}
		if (forwards.to != backwards.from) {
			error('Relationship objects do not correlate', forwards, relationshipEnd_To, INCONSISTENT_RELATIONSHIP_ENDS)
			error('Relationship objects do not correlate', backwards, relationshipEnd_From, INCONSISTENT_RELATIONSHIP_ENDS)
		}
	}

	@Check
	def void relationshipNavigation(RelationshipNavigation it) {
		if (objectOrRole != null && object != null) {
			if (objectOrRole instanceof RelationshipEnd) {
				if ((objectOrRole as RelationshipEnd).to != object) {
					error('Role refers to another object', it, relationshipNavigation_ObjectOrRole, INCONSISTENT_RELATIONSHIP_NAVIGATION)
				}
			} else {
				error('Role refers to an object', it, relationshipNavigation_ObjectOrRole, INCONSISTENT_RELATIONSHIP_NAVIGATION)
			}
		}
	}

	@Check
	def simpleFeatureCall(SimpleFeatureCall it) {
		if(receiver != null && !receiver.eIsProxy && !receiver.instanceValued)		
			error('Cannot call a feature on ' + receiver?.eClass?.name + ' ' + receiver.fullyQualifiedName?.lastSegment, it, featureCall_Receiver)
		if(feature != null && !feature.eIsProxy && feature.isOperation) 
			error('Operation ' + feature.fullyQualifiedName?.lastSegment + ' must be called with parentheses', it, featureCall_Feature)
	}

	@Check
	def operationCall(OperationCall it) {
		if(receiver != null && !receiver.eIsProxy && !receiver.instanceValued)		
			error('Cannot call an operation on ' + receiver?.eClass?.name + ' ' + receiver.fullyQualifiedName?.lastSegment, it, featureCall_Receiver)
		if(feature != null && !feature.eIsProxy && !feature.isOperation && !isCastExpression) 
			error('Feature ' + feature.fullyQualifiedName?.lastSegment + ' cannot be called with parentheses', it, featureCall_Feature)
	}

	@Check
	def terminatorOperationCallReceiver(TerminatorOperationCall it) {
		switch receiver {
			TerminatorDefinition, 
			SimpleFeatureCall: {
				// noop
			}
			default:
				error('Cannot call terminator operation on ' + receiver.eClass.name, receiver, null)
		}
	}
	
	@Check
	def indexedExpression(IndexedExpression it) {
		if(!receiver.instanceValued)	
			error('Cannot use ' + receiver.eClass.name + ' as indexed element', receiver, null)
	}
	
	@Check
	def characteristicCallReceiver(CharacteristicCall it) {
		if(!receiver.instanceValued)
			error('Cannot call characteristic on ' + receiver.eClass.name, receiver, null)
	}

	@Check
	def modelNamesAreUnique(MaslModel it) {
		val allDomainsInFile = elements.filter(DomainDefinition) 
			+ elements.filter(ProjectDefinition).map[domains].flatten
		checkNamesAreGloballyUnique(allDomainsInFile, domainDefinition)
		checkNamesAreGloballyUnique(elements.filter(ProjectDefinition), projectDefinition)
		checkNamesAreGloballyUnique(elements.filter(ObjectServiceDefinition) 
			+ elements.filter(ObjectFunctionDefinition), objectServiceDefinition, objectFunctionDefinition)
		checkNamesAreGloballyUnique(elements.filter(StateDefinition), stateDefinition)
		checkNamesAreGloballyUnique(elements.filter(DomainServiceDefinition) 
			+ elements.filter(DomainFunctionDefinition), domainServiceDefinition, domainFunctionDefinition)
	}
	
	@Check
	def domainNamesAreUnique(DomainDefinition it) {
		checkNamesAreGloballyUnique(objects, objectDeclaration)
		checkNamesAreGloballyUnique(services + functions, domainServiceDeclaration, domainFunctionDeclaration)
		checkNamesAreGloballyUnique(terminators, terminatorDefinition)
		checkNamesAreGloballyUnique(relationships, relationshipDefinition)
		checkNamesAreGloballyUnique(objectDefs, objectDefinition)
		checkNamesAreGloballyUnique(typeForwards, typeForwardDeclaration)
		checkNamesAreGloballyUnique(types, typeDeclaration)
		checkNamesAreGloballyUnique(exceptions, exceptionDeclaration)
	}
	
	@Check
	def terminatorNamesAreUnique(TerminatorDefinition it) {
		checkNamesAreGloballyUnique(operations + functions, terminatorServiceDeclaration, terminatorFunctionDeclaration)
	}
	
	@Check
	def parameterNamesAreUnique(Parameterized it) {
		checkNamesAreLocallyUnique(parameters)
	}
	
	@Check 
	def objectNamesAreUnique(ObjectDefinition it) {
		checkNamesAreLocallyUnique(attributes)
		checkNamesAreLocallyUnique(services + functions)
		checkNamesAreLocallyUnique(events)
		checkNamesAreLocallyUnique(states)
	}
	
	@Check
	def relationNamesAreUnique(RegularRelationshipDefinition it) {
		if(forwards.name == backwards.name) {
			error('Duplicate role name ' + forwards.name, forwards, abstractNamed_Name, DUPLICATE_NAME)
			error('Duplicate role name ' + backwards.name, backwards, abstractNamed_Name, DUPLICATE_NAME)
		}
	}
	
	@Check 
	def codeBlockNamesAreUnique(CodeBlock it) {
		// TODO more checks when feature scopes are implemented
		checkNamesAreLocallyUnique(variables)
	}

	private def checkNamesAreLocallyUnique(Iterable<? extends EObject> elements) {
		val name2element = HashMultimap.create
		for(element: elements) {
			val name = element.eGet(abstractNamed_Name)
			name2element.put(name, element)
			val duplicates = name2element.get(name)
			switch duplicates.size {
				case 1: {
					// noop
				}
				case 2: 
					duplicates.forEach[
						error('Duplicate name ' + name, it, abstractNamed_Name, DUPLICATE_NAME)
					]
				default:
					error('''Duplicate «element.eClass.name» named '«name»'«»''', element, abstractNamed_Name, DUPLICATE_NAME)
			}
		}
	}
	
	private def checkNamesAreGloballyUnique(Iterable<? extends EObject> elements, EClass... eClasses) {  
		if(!elements.empty) {
			val resource = elements.head.eResource
			val uri = resource.URI
			val fileExtension = uri.fileExtension
			val index = resource.resourceDescriptions		
			for(element: elements) {
				val elementName = element.fullyQualifiedName
				val siblings = eClasses.map[
					index.getExportedObjects(it, elementName, false)
				].flatten.filter[
					((fileExtension == 'int' || fileExtension == 'prj') && uri == EObjectURI.trimFragment)
					|| (fileExtension != 'int' && fileExtension != 'prj' && EObjectURI.fileExtension != 'int' && EObjectURI.fileExtension != 'prj')
				].iterator
				if(siblings.hasNext) {
					siblings.next
					if(siblings.hasNext) {
						error('''Duplicate «eClasses.map[name].join('/')» named '«elementName.toString('::')»'«»''', 
							element, abstractNamed_Name, DUPLICATE_NAME)
					}
				}
			}
		}		
	}
	
	@Check
	def declarationPresent(ObjectDefinition it) {
		if(getDeclarations(objectDeclaration, index).empty)
			warning('Object is has not been declared', it, abstractNamed_Name, MISSING_DECLARATION)
	}	
	
	@Check
	def declarationPresent(ObjectFunctionDefinition it) {
		if(getDeclarations(objectFunctionDeclaration, index).empty)
			warning('Object function has not been declared', it, abstractNamed_Name, MISSING_DECLARATION)
	}	
	
	@Check
	def declarationPresent(ObjectServiceDefinition it) {
		if(getDeclarations(objectServiceDeclaration, index).empty)
			warning('Object service has not been declared', it, abstractNamed_Name, MISSING_DECLARATION)
	}
	
	@Check
	def declarationPresent(StateDefinition it) {
		if(getDeclarations(stateDeclaration, index).empty)
			warning('State has not been declared', it, abstractNamed_Name, MISSING_DECLARATION)
	}
	
	@Check
	def declarationPresent(DomainFunctionDefinition it) {
		if(getDeclarations(domainFunctionDeclaration, index).empty)
			warning('Domain function has not been declared', it, abstractNamed_Name, MISSING_DECLARATION)
	}	
	
	@Check
	def declarationPresent(DomainServiceDefinition it) {
		if(getDeclarations(domainServiceDeclaration, index).empty)
			warning('Domain service has not been declared', it, abstractNamed_Name, MISSING_DECLARATION)
	}
	
	@Check
	def declarationPresent(TerminatorFunctionDefinition it) {
		if(getDeclarations(terminatorFunctionDeclaration, index).empty)
			warning('Terminator function has not been declared', it, abstractNamed_Name, MISSING_DECLARATION)
	}	
	
	@Check
	def declarationPresent(TerminatorServiceDefinition it) {
		if(getDeclarations(terminatorServiceDeclaration, index).empty)
			warning('Terminator service has not been declared', it, abstractNamed_Name, MISSING_DECLARATION)
	}
	
	@Check
	def definitionPresent(ObjectDeclaration it) {
		if(getDefinitions(objectDefinition, index).empty)
			warning('Object has not been defined', it, abstractNamed_Name, MISSING_DEFINITION)
	}	
	
	@Check
	def definitionPresent(ObjectFunctionDeclaration it) {
		if(getDefinitions(objectFunctionDefinition, index).empty)
			warning('Object function has not been defined', it, abstractNamed_Name, MISSING_DEFINITION)
	}	
	
	@Check
	def definitionPresent(ObjectServiceDeclaration it) {
		if(getDefinitions(objectServiceDefinition, index).empty)
			warning('Object service has not been defined', it, abstractNamed_Name, MISSING_DEFINITION)
	}	
	
	@Check
	def definitionPresent(StateDeclaration it) {
		if(getDefinitions(stateDefinition, index).empty)
			warning('State has not been defined', it, abstractNamed_Name, MISSING_DEFINITION)
	}	
	
	@Check
	def definitionPresent(DomainFunctionDeclaration it) {
		if(getDefinitions(domainFunctionDefinition, index).empty)
			warning('Domain function has not been defined', it, abstractNamed_Name, MISSING_DEFINITION)
	}	
	
	@Check
	def definitionPresent(DomainServiceDeclaration it) {
		if(getDefinitions(domainServiceDefinition, index).empty)
			warning('Domain service has not been defined', it, abstractNamed_Name, MISSING_DEFINITION)
	}	
	
	@Check
	def definitionPresent(TerminatorFunctionDeclaration it) {
		if(getDefinitions(terminatorFunctionDefinition, index).empty)
			warning('Terminator function has not been defined', it, abstractNamed_Name, MISSING_DEFINITION)
	}	
	
	@Check
	def definitionPresent(TerminatorServiceDeclaration it) {
		if(getDefinitions(terminatorServiceDefinition, index).empty)
			warning('Terminator service has not been defined', it, abstractNamed_Name, MISSING_DEFINITION)
	}	
	
	private def IResourceDescriptions getIndex(EObject element) {
		element.eResource.resourceDescriptions	
	}
	
	static val INT_PATTERN = Pattern.compile('[0-9]+')
	
	@Check
	def relationName(RelationshipDefinition it) {
		if(!name.startsWith('R'))
			warning("Relationship name should start with an 'R'", it, abstractNamed_Name)
		if(!INT_PATTERN.matcher(name.substring(1)).matches)
			warning("Relationship name should end with an integer number", it, abstractNamed_Name)
	} 
	
	@Check
	def inheritanceCycle(ObjectDeclaration it) {
		if(findInheritanceCycle(newHashSet)) {
			error('Object has a cycle in its supertype hierarchy', it, abstractNamed_Name, CYCLIC_INHERITANCE)
		}
	}
	
	private def boolean findInheritanceCycle(ObjectDeclaration object,
		Set<ObjectDeclaration> seenSubtypes) {
		if (!seenSubtypes.add(object))
			return true
		val domain = object.eContainer as DomainDefinition
		domain.relationships.filter(SubtypeRelationshipDefinition).filter[subtypes.contains(object)].map [
			supertype
		].exists [
			findInheritanceCycle(new HashSet(seenSubtypes))
		]
	}
	
	@Check 
	def checkFileExtension(MaslModel model) {
		val fileExtension = model.eResource.URI.fileExtension
		model.elements.forEach [
			val expectedFileExtensions = switch it {
				ProjectDefinition: #['prj']
				DomainDefinition: #['mod', 'int']
				ObjectServiceDefinition: #['svc']
				DomainServiceDefinition: #['ext', 'scn', 'svc']
				ObjectFunctionDefinition, DomainFunctionDefinition: #['fn']
				TerminatorServiceDefinition, TerminatorFunctionDefinition: #['tr']
				StateDefinition: #['al']
			}
			if(!expectedFileExtensions.contains(fileExtension)) {
				error('''«eClass.name» elements should be defined in a file with extension «
				expectedFileExtensions.map['\'.'+ it + '\''].join(' or ')».''', it, abstractNamed_Name)
			}
		]
	}
}

