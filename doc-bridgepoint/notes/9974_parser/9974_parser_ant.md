---

This work is licensed under the Creative Commons CC0 License

---

# Incremental Parsing of OAL bodies
### xtUML Project Analysis Note

### 1. Abstract

For large bodies and/or large models, the parser can be quite slow. This can
lead users to disable "Parse while editing". Additionally, slow parsing limits
the utility of the content assist capability because a user has to wait for a
parse of the body before being presented with completion proposals.

Parsing performance must be improved so that users can enable parse while
editing and use content assist without unreasonable delays.

### 2. Document References

<a id="2.1"></a>2.1 [Service Pro SR #9974](https://support.onefact.net/issues/9974) Headline issue  
<a id="2.2"></a>2.2 [#9763 Content assist engineering design note](https://github.com/xtuml/bridgepoint/blob/master/doc-bridgepoint/notes/9763_content_assistance/9763_content_assistance_dnt.md)  

### 3. Background

Modern languages in IDEs such as Eclipse make use of technique called
incremental parsing. This technique leverages the fact that the diff between
source files between sequential parses is in most scenarios very small
(especially when a parse is triggered while editing). Incremental parsers reuse
the parsed AST when parsing to avoid re-parsing whole files for small changes.

The OAL parser is implemented as a "batch parser". It throws away the AST after
each parse and parses whole action bodies at a time.

It is recommended that the reader take some time to review the engineering
documentation from when content assist was first introduced to understand in
general how the current parsing architecture works [[2.2]](#2.2).

During the implementation of the content assist feature, there was
experimentation done with partial parsing of bodies. A new class
`PartialParseRunnable` was introduced to mirror the `ParseRunnable` class, but
did some calculation to start parsing at a specific point in a block.  The work
was abandoned (hidden behind a preference) because it was not consistent enough
at determining the starting point. This work will be used as a basis for the
new work.

### 4. Requirements

4.1 A mechanism shall be added to the parser to allow a partial parse, where
only sections of a body which were changed or affected by a change are
re-parsed.  
4.2 The "Parse all" mechanism shall be unaffected by the new partial parsing
mechanism.  
4.3 The chosen mechanism shall consider performance with respect to "Parse while
editing" and content assist parsing.

### 5. Analysis

5.1 Incremental parsing

Moving to a strategy where incremental parsing techniques were fully utilized
would be ideal, however the technology and methods used to create the OAL parser
are such that doing so would be a massive undertaking and would require a
refactoring of much of the work that has been done in the OAL parser to date.
This path is out of reach for the scope of this project.

5.2 General strategies for improving performance without incremental parsing

Although we cannot implement an incremental parsing strategy in the normal
sense of the phrase, there are several things we can do to "fake" it.

5.2.1 The meta-model is the AST

First, a general observation is that unlike many applications which utilize
parser generators, the xtUML model itself serves as the AST for downstream tools
(editors, compilers, interpreters). Because of this, we can keep the meta-model
instances between sequential parses while the other AST generated by the Antlr
parser is thrown away. The OAL parse grammar makes no effort to instruct Antlr
to build a useful AST, because the meta-model is the AST. Currently, the parser
simply deletes all OAL related instances in a body at the beginning of parse and
recreates them all from the re-parse. This note proposes instead only deleting a
isolated subset of the OAL related meta-model instances, and replacing them with
the result of a limited re-parse.

5.2.2 Parsing strings, not files

The OAL parser parses input strings and not files. This is because the textual
OAL for xtUML models is stored in a string attribute of meta-model instances.
Because the parser is already set up to do things this way, the input string can
easily be modified before passing it to the parser. For example, if only one
statement is affected by an edit, the editor could pass only the text of that
single statement to the parser instead of the full text of the OAL action body.

5.2.3 Parse granularity

A decision must be made to establish what logical chunk of OAL which has been
affected by an edit must be re-parsed. This can be thought of as an "atomic unit
of parsing". Today the parse granularity is the action body. Any edit to an
action body is considered to affect the entire body. Another choice could be
block. If any edit occurs in the confines of a block, the entire block should be
re-parsed. Blocks are not optimal because they are not bounded. For instance, if
a user is typing on the first line of a large body, the entire top level block
must be re-parsed making it the same as re-parsing the whole body. An extremely
fine granularity would be something like individual expressions. A re-parse only
processes text of a single expression that is affected. This sounds nice, but it
gets complicated quickly because not everything is an expression. If this
granularity were taken, not only would re-parsing of expressions need to be
supported, but also re-parsing of variables, invocation statements, etc.

Statement is a better selection for granularity. Statements are bounded (at
least practically speaking). That is to say, an edit affecting a statement will
not cause a large amount of extraneous text to be parsed as with blocks. Special
handling must be done for statements which have child blocks (if, while, for)
such that if the edit only affects the conditional expression (if, while) or the
definition of the for statement the entire child block should not be re-parsed.
Another property of statements is that the entire body is made up of consecutive
statements with no gaps. Unlike expressions, there is no cursor location in the
body that cannot be defined as being part of a statement.

5.3 Partial parse flow

The partial parse flow can be broken down into three stages:
* pre-processing
* parsing
* post-processing

These three stages will be discussed in the following sections.

5.3.1 Partial parse pre-processing

The first step of partial parsing is to determine which statements are affected
by the edit. This can be done using a delta provided by the OAL text editor.
Given the start location of the changeset, the end location of the changeset,
the current contents of the body, and the number of characters added or removed,
the parser can determine which parsed statements are affected by the change.
Additionally, it can trim away the text of unaffected statements from the
updated body text to leave only a chunk of text which represents the part of the
body which needs to be re-parsed.

5.3.1.1 Statement location information

The calculation described above hinges on the existence of accurate line and
column information of parsed statements in the meta-model. Currently, the
Statement class (`ACT_SMT`) contains `LineNumber` and `StartPosition` which
represent the line and column of the first token in the statement. For partial
parsing to work, two more attributes representing the end line number and column
number must be added.

5.3.1.2 Crossing block boundaries

The parser runs 500 milliseconds after a user stops typing. Although it is not
the most common scenario, it is certainly possible that an edit could affect
statements in multiple blocks.

Consider the following OAL. The blocks and statements have been labeled for
convenient identification:
```
  if ( true )                            // block 1   statement 1
    LOG::LogInfo( message:"Hello, " );   // block 1.1 statement 1
    LOG::LogInfo( message:"World!" );    // block 1.1 statement 2
  end if;
  LOG::LogInfo( message:"the " );        // block 1   statement 2
  LOG::LogInfo( message:"outer " );      // block 1   statement 3
  LOG::LogInfo( message:"block" );       // block 1   statement 4
```

Now suppose an edit has occurred resulting in the following diff:
```diff
  if ( true )                            // block 1   statement 1
    LOG::LogInfo( message:"Hello, " );   // block 1.1 statement 1
-   LOG::LogInfo( message:"World!" );    // block 1.1 statement 2
+   LOG::LogInfo( message:"Reader." );   // block 1.1 statement 2
  end if;
  LOG::LogInfo( message:"the " );        // block 1   statement 2
- LOG::LogInfo( message:"outer " );      // block 1   statement 3
  LOG::LogInfo( message:"block" );       // block 1   statement 4
```

Doing the calculation described above would result in `block 1.1 statement 1`
being the last unaffected statement before the diff and `block 1 statement 4`
being the first unaffected statement after the diff. Additionally, the blob of
text which would need to be re-parsed would be:
```
    LOG::LogInfo( message:"Reader." );    // block 1.1 statement 2
  end if;
  LOG::LogInfo( message:"the " );        // block 1   statement 2
```

For reasons that will be discussed in more detail in section 5.3.2, it is not
possible to do a partial parse in this way where the first statement is in an
inner block and continues to parse in an outer scope.

5.3.1.3 Breaking it down further

From here, the pre-processing step can break down the text to parse even
further, delimiting on end block makers (`end if;`, `end for;`, and `end
while;`). The last unaffected before and first unaffected after statements
could also be updated for each sub text so they can be parsed independently of
one another. The diff in the previous section would result in two separate
blobs of parse texts:
```
    LOG::LogInfo( message:"Reader." );    // block 1.1 statement 2
```
where `block 1.1 statement 1` is the last unaffected statement before the diff
and there is now bounding end statement (parse to the end of the block). And:
```
  LOG::LogInfo( message:"the " );        // block 1   statement 2
```
where `block 1 statement 1` is the last unaffected statement before the diff and
`block 1 statement 4` is the first unaffected statement after the diff.

5.3.1.4 Handling side effects

Of course when modifying a statement, the edited portion of the body is not
necessarily the only portion that is affected. For example consider the
following OAL diff:
```diff
  LOG::LogInfo( message:"Starting..." );             // statement 1
- select any foo from instances of FOO;              // statement 2
+ select any foo1 from instances of FOO;             // statement 2
  LOG::LogInfo( message:"Printing attributes..." );  // statement 3
  LOG::LogInteger( message:foo.x );                  // statement 4
  LOG::LogInteger( message:foo.y );                  // statement 5
```
According to this diff, `statement 1` is the last unaffected statement before
the diff and `statement 3` is the first unaffected statement after the diff,
therefore only `statement 2` should be re-parsed. It is obvious that doing so
would result in corrupted data because `statement 4` and `statement 5` refer to
the variable `foo` which would no longer exist. The pre-processor must recognize
this situation and add statements which depend on earlier statements to the list
of sections that must be re-parsed.

Analysis of the meta-model has shown that variables are the only elements in
this situation which can be declared in a body. In other words, there is no
other element which can be defined in a statement and be referred to by another
statement later in the body.

5.3.2 Partial block parsing

In the usual parse flow, the top level production rule is `action` and is used
to parse an entire body. When this rule is invoked the first step it takes is to
delete all the OAL blocks and statements from the body so that it can be
re-parsed. When `PartialParseRunnable` was introduced (see section 3) a new
production rule `partial_block` was introduced which is able to match a list of
statements. The OAL associated with `partial_block` knows how to delete only the
statements after a certain point in the block without deleting the other blocks
and statements in the body. This strategy can be reused here also adding a
bounding statement after the diff that should not be deleted.

As mentioned in section 5.3.1.2, blobs of text which cross block boundaries
cannot be parsed using the `partial_block` production rule because they do not
represent a syntactically correct list of statements -- there is an unbalanced
"end" token.

5.3.3 Partial parse post-processing

Some post processing must be done to ensure that statements not affected by the
parse remain correct and future parses will succeed. In particular there are
several classes that store line and column information including statements and
expressions. It is not likely that an edit will not result in a change of
overall length of the body. After a partial parse, information gleaned from the
diff must be used to update the line and column information of all OAL instances
in the body that have such information and occur after the diff. In the majority
of the cases, the line number must be incremented/decremented by the number
of lines added/removed due to the edit. For elements occurring on the last line
of the diff, column number must also be taken into account.

5.4 Leverage of OAL

Almost all of the calculations described in the 5.3 section can be
implemented in OAL. Doing all of the pre-processing and post-processing
in OAL improves code maintainability and reduces complexity. These operations
will be implememted either as OAL validation utility functions or as operations
on meta-model instances (chosen during design phase).

### 6. Work Required

TODO

### 7. Acceptance Test

TODO

### End
