---

This work is licensed under the Creative Commons CC0 License

---

# Not possible to specify datatypes with the same name at different levels.
### xtUML Project Design Note


### 1. Abstract

If an enumeration data type with the same name exists at the system level and inside a component, BridgePoint 
currently gives a syntax error that reads there are mulitple enumerations found. This issue is raised to provide a mechanism
that allows types with the same name to exist without this error.

#
### 2. Document References

<a id="2.1"></a>2.1 [BridgePoint DEI #4896](https://support.onefact.net/issues/4896)   
<a id="2.2"></a>2.2 [This issue's analysis](4896_scoped_enum.ant.md)  


### 3. Background

See the [background in the analysis note](4896_scoped_enum.ant.md).

## 4. Requirements

See the [analysis note](4896_scoped_enum.ant.md).

### 5. Analysis

See the [analysis note](4896_scoped_enum.ant.md).

### 6. Design

The work required section of this issue's analysis note described proposed grammar change to satisfy the requirements of this issue. Design started with that grammar. However, discussion and and test during this design phase led to a more flexible grammar. The grammer described in the analalysis would require a full-path specification. Discussion and test led to the desire to allow a "partial path" solution. This "partial path" solution would allow a user to specify only as much path as is neccessary to disambiguate a conflict. This has the addtional benefit of not requiring a system name to always be present. 

6.1 Here is grammar before any change was made for this issue:  
```
scoped_access
   :
    scoped_data_type
    TOK_DOUBLECOLON!
    scoped_member
  ;
```

6.2 Here was the grammar proposed as a starting point in analysis:  
```
scoped_access
   :
    (
    scoped_model
    TOK_DOUBLECOLON!
    scoped_package
    )?
    scoped_data_type
    TOK_DOUBLECOLON!
    scoped_member
  ;
  
scoped_model!
  :
    general_name
  ;
  
scoped_package!
  :
    general_name
    (
    TOK_DOUBLECOLON!
    scoped_package
    )*
  ;
  
```


6.3 Here is the grammar that implements partial-path matching:  
```
scoped_access
   :
   (
        scoped_path
        scoped_data_type
        TOK_DOUBLECOLON!
        scoped_member
    )
  ;
scoped_path
  :
    ( 
      ( scoped_path_segment scoped_path_segment )=>
        scoped_path_segment
    )*
  ;
scoped_path_segment
  :
    scoped_path_segment_name
    TOK_DOUBLECOLON!
  ;
```

6.3.1 Partial path grammar implementation  
In this implementation the original scoped_access rule was modified by adding a new rule, scoped_path. This scoped_path rule is defined to have 0 or more elements. Note that when 0 scoped_path element are present the behavior is identical to the tool behior before any scoped path was introduced.  

With the grammar change in place, OAL Validation Utility operations were added for elements generated by the parser. Note that the implemenation of these new OAL Validation Utility functions only needed to perform validation of the scoped_path expression, it did not need to create any meta-model instances because the meta-model was NOT changed by this issue.  

Implementation of validation of the partial-path match had to consider that full validation of a scoped_access rule which includes one or more scoped_path_segments can not be completed until the entire expression is parsed. This situation where validation had to be "delayed" until the entire expression was in-hand was new to the BridgePoint archetecture. Before this, grammar rules validated in OAL Validation utility functions always had enough information as each rule completed to before valdidation of the expression. To handle this situation where the entire scoped_access rule needed to be parsed before it was validated a scoped_path_segment cache was introduced. 

6.3.1.1 Caching of path segment information  

To allow the parse of a scoped_access rule to happen before validation 2 main implementation artifacts were added:

6.3.1.1.1 Oal_validate.java::ScopedSegment

Implementation for parser rule validation and instance creation is performed by functions (S_SYNC) that are implemented in OAL. The BridgePoint archetecture allows a BridgePoint developer to mark S_SYNCs  that contain these parser implementation functions. The mark, which is handled by MC-Java, is placed in the description field of a package that contains these operations is:  
ParserValidateFunction: TRUE

When a S_SYNC is marked as "ParserValidateFunction: TRUE" (or ParserUtilityFunction: TRUE) the generated code is output to a file: bp.als.oal/src/org/xtuml/bp/als/oal/Oal_validate.java. This Oal_validate.java file is initially created from an archetype, bp.als/arc/validate_gen.arc.  

For this work, validate_gen.arc shall be modified and a new class and array introduced to allow the parsed scoped segments to be changed. Following is the class and array that shall be introduced:


```
  private ArrayList<ScopedSegment> scopedSegments = new ArrayList<ScopedSegment>();

  class ScopedSegment {
  	Token token;
  	String segmentName;
  		
  	/**
  	 * Prevent no-arg constructor
  	 */
  	private ScopedSegment() {			
  	}
  		
  	// Only used by the outer class
  	ScopedSegment(Token tok, String name) {
      this();
  		token = tok;
  		segmentName = name;
  	}
  }
```

6.3.1.1.2 ooaofooa/Functions/OAL Validation Scoped Access  

Given the new archetectural mechanism put in place to cache path segments, a mechanism to interact with the path segments from OAL is needed. Note that such parser-related utility functions are , by convention, kept in the package OAL Validation Utility Functions in BridgePoint. This is simply convention, and it was observed during design that there would be quite a few new utility operations introduced in support of this scoped-path "cache". A new package was therfore introduced as a sibling to OAL Vaidation Utility Functions. The new package shall be named: OAL Validation Scoped Access.  The following operations shall be introduced in this new package:  

  * ```void scopedmatches_reset()```  
This is used to reset the path cache. This is called as the first statement in Scoped_path_start(), and is placed in this location because this is only called when a scoped_path is being parsed.
  * ```void scopedmatches_add_segment(Token, String)```  
This is used to add a new path segment to the cache. This is called during Scoped_path_segment_name_validate() a segment has been parsed. The Token parameter is the parser Token that represents the segment being parseed. This Token is used for error reporting. The name is the text string of the segment name and it is used during validation.

  * ```inst_ref_set<Packageable Element> scopedmatches_collect(String lookaheadText, boolean validate)```  
This operation collects all possible matches. From OAL implmentation point of view, this routine is by far the most significant function introduced. This function is called in Scoped_data_type_validate() in the case where a scoped_path has been parsed (scopedmatches_size() is greater than 0), as well as by content assist (Scoped_path_lookahead_content_assist()). The "validate" parameter is true for when called for validatation and false when called for context assist. The lookaheadText parameter is empty when called for validation, and is used as the next string to collect a set of instance for in the context assit call. The return value here is a set of elements that are the possible matches for the current path context. There was significant code change fallout in the decision to implement this routine interitively instead of recursively. See Design comment 7.1 for more information about this function and its implementation. 
  * ```int scopedmatches_size()```  
Return the number of scoped_path segments in the cache.
  * ```String scopedmatches_get_segment(int index)```  
Returns the path segment string assocaited with the given index.
  * ```Token scopedmatches_get_token (int index)```  
Returns the path segment Token assocaited with the given index.



### 7. Design Comments

7.1 Implemenation of the "match collection" in OAL Validation Scoped Access::scopedmatches_collect()  

This function iteratively collects all possible visible options that 
inst_ref_set<Packageable Element>  
TODO:
   
### 8. User Documentation

The existing documenation shall be modified to update places that describe this behavior as an error and to describe the 
new behavior.  

### 9. Unit Test

9.1 Assure that duplicate-named enumeration data types may exist in separate packages in a model.  
9.2 Assure that duplicate-named constant data types may exist in separate packages in a model.  
9.3 Assure that duplicate-named structured data types may exist in separate packages in a model.  
9.4 Assure that duplicate-named user data types may exist in separate packages in a model.  Note 
that this is already allowed in the tool today. However, it is simply added here for completeness.  
9.5 Test backwards compatibility to assure that existing models do not have parse errors unless duplicates are present.  

### End
